1.不设定时间的运动
    思路：
        1.target 设定一个固定值step；
        2.每次都要获取最新的位置，在最新的位置上加step；（核心）
        3.停止条件： 最新位置>=target
        问题：如果target/step不是整数，那么当超出距离时被迅速拉回目标值，会出现滚动条的闪烁；
        解决方式：给边界判断+step；
        一定要加return；
2.设定总时间，求出步长的运动
    思路
        1.需要的条件：duration(总时间) interval(频率) target(总距离)
        2.根据已知条件求出 step -》target/duration*interval;
        3.每次都要获取最新的位置，在最新的位置上加step；
        4.停止条件： 最新位置>=target
        但是，它不需要处理边界值； 一定要加return；
3.通过tween算法的Linear公式，做运动
    思路：
        1.首先封装Linear公式
        2.通过时间不断累加，根据公式求出我们目前应该在的位置-设置位置；
        3.停止条件：time>=duration(总时间)
4.利用固定步长step和setTimeout实现运动-递归
    1.通过当前位置和target比较判断向左走还是向右走
    2.每次都要获取最新的位置，在最新的位置上加step；（核心）
    3.停止条件：+=step 最新位置>=target/ -=step最新位置<=target
    问题：1.定时器返回在私有作用域中会导致元素左右晃动；
         2.匿名函数不断创建但不销毁的问题
    解决办法：
        1）把定时器返回值放在元素自定义属性上；避免全局变量的冲突
        2）清除没用的定时器
        3）通过_move解决；
5.运动处理的4个小技巧
1）给边界判断+step；
2）把定时器返回值放在元素自定义属性上；避免全局变量的冲突
3）清除没用的定时器
4）通过_move解决匿名函数累加并且不销毁的问题；
6.完成版左右切换图片轮播思路：
1）ajax数据获取和解析
2）绑定数据
3）延迟加载
4）图片自动轮播
5）焦点自动轮播
6）鼠标移入停止，移出继续；
7）点击焦点手动切换图片
8）点击左右按钮进行左右切换
7.构造函数封装思路
1）把全局变量都作为私有属性
2）全局函数都作为公有方法
3）注意constructor指向
4）init（）初始化函数中，就是我们代码执行的思路；
5）改变this指向；
8.this复习总结：
1）函数调用时看前面是否有"."，"."前面是谁，this就是谁
2）自执行函数中，this永远是window
3）通过触发元素的事件，执行绑定的方法时，方法中的this，指向当前这个元素
4）构造函数中的this是实例；
5）call，bind,apply改变this；
    回调时一般也是window
9.异步复习
1）事件
2）ajax
3）回调函数
4）定时器；
10.运动库的封装思路：
    1）首先封装一个Linear函数-公式
    2）明白要传的参数：curEle,target,interval,effect,callback
    3)设置公式中要传参数的初始值；begin和change 都是通过target求出
    4）开启一个定时器，进行时间的累加，通过公式求出目前的位置，进行设置
    停止条件：time>=duration;

    里面effect考虑思路：
    1）设置默认的运动样式
    2）当传数字，用到%的小技巧：有几种情况就%几；
    3）当传数组 zhufengEffect[ary[0]][ary[0]],一定注意长度的判断；
    4）当传函数，直接赋值给callback=effect;







