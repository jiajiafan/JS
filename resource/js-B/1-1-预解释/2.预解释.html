<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
1.预解释：在当前作用域下，JS代码执行之前，浏览器会把带VAR和带function进行提前声明或者定义；
域：空间或者范围；
2.作用域：全局作用域和私有作用域
全局作用域：在浏览器打开HTML页面的时候，会形成一个供JS执行的环境；在全局作用域环境下，里面所有的变量和函数，实际上就是window的属性和方法；
私有作用域：在函数被调用的时候，形成一个私有作用域；
3.声明和定义的概念
声明：告诉浏览器有这么一个名字；但是不知道值； eg:var a;
定义：给之前声明的这个名字赋值；eg:var a=2;
注：对带VAR和带function的声明和定义是不同的：
带VAR：在预解释阶段，只声明，不定义；
带function：在预解释阶段，声明+定义；
4.函数定义和执行阶段：
1）函数定义3阶段：
    1.开辟一个堆内存空间，浏览器默认为其分配一个地址；eg:xxff00;
    2.把函数体中的JS代码做为字符串存放在这个堆内存空间中
    3.把地址赋值给函数名；
2）函数执行3阶段：
    1.给形参赋值
    2.预解释
    3.JS代码从上往下执行；
5.作用域链：在函数执行的时候，会形成一个私有作用域A，私有作用域中找一个变量,这个变量是否在作用域A中定义过：
1）如果变量在A中定义过，那这个A中所有的此变量，都是私有变量；
2）如果变量没在A中定义过，就会往A的上级作用域进行查找，有的话就赋值，没有就继续往上找，。。。找到window都没，报错！
6.带var和不带var的区别：
1）带var：1）会预解释 2）如果带var在全局环境下，它是window的全局属性；
2）不带var:1）不会预解释 2）首先会往上找；如果是赋值的话，找到window还没有，就变成window上的全局属性；
7.JS中的内存，按照功能的不同：
1）栈内存：提供了一个供JS代码执行的环境：全局作用域，私有作用域；
2）堆内存：存储引用数据类型的值； 对象数据类型：存属性和属性值； 函数数据类型：代码字符串；
<script>
    /*1.预解释阶段：
    * var a=function a(){alert(2)};
    * 2.JS代码从上往下执行；
    * alert(a);/
    *a=1;
    * alert(a);//1
    * alert(a);//1;
    * a=2;
    * alert(a);//2
    * a(); 2()->报错
    * */
    alert(a);//function a(){alert(2)}; undefined
    var a=1;
    alert(a);//1 1
    function a(){alert(1)};
    alert(a);//1
    var a=2;
    alert(a);//2
    function a(){alert(2)};
    a();//报错
</script>
</body>
</html>





